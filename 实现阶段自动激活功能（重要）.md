# 实现阶段自动激活功能（重要）

## 功能需求

实现大作业阶段的自动状态管理：
- 当阶段到达 `start_date` 时，自动将状态从 `pending` 变为 `active`
- 当阶段到达 `end_date` 时，自动将状态从 `active` 变为 `completed`

## 实现方案

采用**定时任务**方案，每分钟自动检查所有阶段状态并更新。

---

## 实现步骤

### 1. 添加依赖包

在 `requirements.txt` 中添加定时任务调度器：

```txt
Flask-APScheduler==1.13.1
```

### 2. 创建调度器服务

创建文件：`app/services/scheduler_service.py`

```python
"""定时任务服务 - 自动更新阶段状态"""
from flask_apscheduler import APScheduler
from app.services.stage_service import StageService
import os


scheduler = APScheduler()


def init_scheduler(app):
    """初始化定时任务调度器"""
    # 只在第一个worker中启动调度器
    # 使用环境变量来控制，避免多个worker重复启动
    import os
    import time
    import sys
    
    # 检查是否是迁移脚本（不启动调度器）
    script_name = os.path.basename(sys.argv[0] if sys.argv else '')
    if script_name.startswith('migrate_') or script_name in ['init_db.py', 'update_stage_status.py']:
        return
    
    # 检查是否已有其他worker启动了调度器
    scheduler_lock_file = '/tmp/tg_edu_scheduler_flask.lock'
    current_pid = os.getpid()
    
    try:
        # 如果锁文件已存在，检查其创建时间
        if os.path.exists(scheduler_lock_file):
            # 检查锁文件是否是最近30秒内创建的（同一批worker）
            lock_age = time.time() - os.path.getmtime(scheduler_lock_file)
            if lock_age < 30:  # 30秒内
                with open(scheduler_lock_file, 'r') as f:
                    lock_pid = f.read().strip()
                print(f"⚠️  Worker {current_pid}: 调度器已在Worker {lock_pid}中启动，跳过")
                return
            else:
                # 过期的锁，删除它（可能是上次运行留下的）
                os.remove(scheduler_lock_file)
        
        # 创建锁文件，写入当前进程ID
        with open(scheduler_lock_file, 'w') as f:
            f.write(str(current_pid))
    except Exception as e:
        print(f"❌ 创建调度器锁文件失败: {e}")
        return
    
    # 配置调度器
    app.config['SCHEDULER_API_ENABLED'] = False  # 禁用API，提高安全性
    
    scheduler.init_app(app)
    
    # 添加定时任务：每分钟检查一次阶段状态
    @scheduler.task('interval', id='update_stage_status', minutes=1, misfire_grace_time=900)
    def scheduled_stage_update():
        """定时更新阶段状态"""
        with app.app_context():
            try:
                print("⏰ 定时任务：开始更新阶段状态...")
                StageService.check_and_update_stages()
                print("✅ 定时任务：阶段状态更新完成")
            except Exception as e:
                print(f"❌ 定时任务：阶段状态更新失败 - {str(e)}")
                import traceback
                traceback.print_exc()
    
    # 启动调度器
    scheduler.start()
    print(f"🚀 Worker {current_pid}: 定时任务调度器已启动")
```

**关键点说明**：

1. **过滤迁移脚本**：检查 `sys.argv[0]` 确保不在迁移脚本中启动调度器
2. **锁文件机制**：使用 `/tmp/tg_edu_scheduler_flask.lock` 确保只有一个worker启动调度器
3. **时效性检查**：锁文件30秒内有效，超时自动删除
4. **应用上下文**：使用 `with app.app_context()` 确保可以访问数据库
5. **异常处理**：完整的错误捕获和日志输出

### 3. 在应用初始化时启动调度器

修改 `app/__init__.py`：

```python
def create_app(config_name='default'):
    """创建Flask应用实例"""
    app = Flask(__name__)
    
    # 加载配置
    app.config.from_object(config[config_name])
    
    # 确保必要的目录存在
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    os.makedirs(os.path.join(app.config['STORAGE_DIR'], 'data'), exist_ok=True)
    os.makedirs(app.config['APPENDIX_FOLDER'], exist_ok=True)
    
    # 初始化扩展
    init_extensions(app)
    
    # 注册user_loader
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))
    
    # 注册Jinja2过滤器
    register_filters(app)
    
    # 注册上下文处理器
    register_context_processors(app)
    
    # 注册蓝图
    register_blueprints(app)
    
    # 初始化定时任务调度器  # <-- 新增
    init_scheduler(app)  # <-- 新增
    
    return app


def init_scheduler(app):  # <-- 新增函数
    """初始化定时任务调度器"""
    from app.services.scheduler_service import init_scheduler as _init_scheduler
    _init_scheduler(app)
```

### 4. 清理启动脚本中的旧锁文件

修改 `start.sh`，在启动Gunicorn前清理旧锁文件：

```bash
echo "启动Web服务器..."
# 清理旧的调度器锁文件
rm -f /tmp/tg_edu_scheduler_flask.lock

# 优化配置：
# - workers: 根据CPU核心数设置 (2 * CPU核心数 + 1)
# - worker-class: 使用gevent异步worker提高并发能力
# - timeout: 降低超时时间，避免长时间占用worker
# - max-requests: 定期重启worker，防止内存泄漏
# - max-requests-jitter: 添加随机抖动，避免所有worker同时重启
exec gunicorn --bind 0.0.0.0:5000 \
    --workers 8 \
    --worker-class gevent \
    --worker-connections 1000 \
    --timeout 120 \
    --max-requests 1000 \
    --max-requests-jitter 100 \
    --access-logfile - \
    --error-logfile - \
    wsgi:app
```

---

## 遇到的问题和解决方案

### 问题1：多个Worker重复执行定时任务

**问题描述**：
- 项目使用 Gunicorn 运行，配置了8个worker进程
- 每个worker都会调用 `create_app()`，导致每个worker都启动了调度器
- 结果：定时任务被执行了8次！

**表现**：
```
🚀 Worker 17: 定时任务调度器已启动
🚀 Worker 21: 定时任务调度器已启动
🚀 Worker 26: 定时任务调度器已启动
```

**解决方案**：

使用**锁文件机制**，让第一个worker创建锁文件并启动调度器，其他worker检测到锁文件存在后跳过初始化：

```python
scheduler_lock_file = '/tmp/tg_edu_scheduler_flask.lock'

if os.path.exists(scheduler_lock_file):
    lock_age = time.time() - os.path.getmtime(scheduler_lock_file)
    if lock_age < 30:  # 锁文件仍然有效
        print(f"⚠️  Worker {current_pid}: 调度器已在其他worker中启动，跳过")
        return
```

**效果**：
```
🚀 Worker 27: 定时任务调度器已启动
⚠️  Worker 28: 调度器已在Worker 27中启动，跳过
⚠️  Worker 29: 调度器已在Worker 27中启动，跳过
⚠️  Worker 30: 调度器已在Worker 27中启动，跳过
```

### 问题2：迁移脚本也启动了调度器

**问题描述**：
- 启动脚本 `start.sh` 在启动Gunicorn之前会运行多个数据库迁移脚本
- 这些迁移脚本也调用了 `create_app()`，导致第一个创建锁文件的是迁移脚本（PID 7）
- 迁移脚本执行完就退出了，调度器也随之停止
- 后续的Gunicorn workers看到锁文件存在，都跳过了调度器启动
- **结果**：没有任何worker运行调度器！

**问题原因**：
```bash
# start.sh 执行顺序
python3 migrate_db.py              # PID 7，创建锁文件，启动调度器
python3 migrate_stage_system.py   # PID 11，看到锁文件，跳过
...
gunicorn ...                       # PID 27-34，全部看到锁文件，全部跳过
```

**解决方案**：

在调度器初始化时，检查当前运行的是否是迁移脚本，如果是则直接返回：

```python
# 检查是否是迁移脚本（不启动调度器）
script_name = os.path.basename(sys.argv[0] if sys.argv else '')
if script_name.startswith('migrate_') or script_name in ['init_db.py', 'update_stage_status.py']:
    return  # 迁移脚本直接返回，不初始化调度器
```

**效果**：
- 迁移脚本：检测到脚本名，跳过调度器初始化 ✅
- Gunicorn workers：第一个worker创建锁文件并启动调度器 ✅

### 问题3：容器重启后旧锁文件残留

**问题描述**：
- 容器重启时，`/tmp` 目录可能保留旧的锁文件
- 新启动的workers检测到锁文件存在（但实际上已经过期）
- 如果锁文件在30秒内，所有workers都会跳过调度器启动

**解决方案**：

在启动Gunicorn前清理旧锁文件：

```bash
# start.sh
echo "启动Web服务器..."
# 清理旧的调度器锁文件
rm -f /tmp/tg_edu_scheduler_flask.lock

exec gunicorn ...
```

---

## 最终实现效果

### 执行流程

1. **容器启动** → 清理旧锁文件 (`rm -f /tmp/tg_edu_scheduler_flask.lock`)
2. **运行迁移脚本** → 检测到是迁移脚本 → 跳过调度器初始化
3. **启动Gunicorn** → 8个workers依次启动
4. **Worker 27（第一个）** → 创建锁文件 → 启动调度器 ✅
5. **Worker 28-34** → 看到锁文件存在 → 跳过调度器初始化 ⏭️
6. **定时任务运行** → 每分钟执行一次 `StageService.check_and_update_stages()` → 自动更新阶段状态

### 日志验证

```
正在初始化数据库...
数据库表创建完成
...
✅ 数据库迁移完成！
🚀 Worker 27: 定时任务调度器已启动  # <-- 只有一个worker启动
⚠️  Worker 28: 调度器已在Worker 27中启动，跳过
⚠️  Worker 29: 调度器已在Worker 27中启动，跳过
⚠️  Worker 30: 调度器已在Worker 27中启动，跳过
⚠️  Worker 31: 调度器已在Worker 27中启动，跳过
⚠️  Worker 32: 调度器已在Worker 27中启动，跳过
⚠️  Worker 33: 调度器已在Worker 27中启动，跳过
⚠️  Worker 34: 调度器已在Worker 27中启动，跳过
启动Web服务器...
[2025-10-21 16:38:57 +0800] [1] [INFO] Starting gunicorn 21.2.0
[2025-10-21 16:38:57 +0800] [1] [INFO] Listening at: http://0.0.0.0:5000 (1)
[2025-10-21 16:38:57 +0800] [1] [INFO] Using worker: gevent
```

### 功能验证

1. **锁文件创建**：
   ```bash
   $ docker exec tg-edu-system cat /tmp/tg_edu_scheduler_flask.lock
   27
   ```

2. **只有一个调度器运行**：
   ```bash
   $ docker logs tg-edu-system 2>&1 | grep "🚀"
   🚀 Worker 27: 定时任务调度器已启动
   ```

3. **定时任务执行**（每分钟一次）：
   ```
   ⏰ 定时任务：开始更新阶段状态...
   ✅ 定时任务：阶段状态更新完成
   ```

---

## 技术要点总结

### 1. Flask-APScheduler 使用

```python
from flask_apscheduler import APScheduler

scheduler = APScheduler()
scheduler.init_app(app)

# 定义定时任务
@scheduler.task('interval', id='task_id', minutes=1)
def my_task():
    with app.app_context():
        # 任务代码
        pass

scheduler.start()
```

**关键配置**：
- `interval`：间隔执行
- `minutes=1`：每分钟执行一次
- `misfire_grace_time=900`：允许15分钟的延迟容错
- `app.app_context()`：确保可以访问数据库

### 2. 锁文件机制

**原理**：利用文件系统的原子性操作防止并发问题

```python
lock_file = '/tmp/tg_edu_scheduler_flask.lock'

# 检查锁
if os.path.exists(lock_file):
    lock_age = time.time() - os.path.getmtime(lock_file)
    if lock_age < 30:  # 有效期内
        return  # 跳过

# 创建锁
with open(lock_file, 'w') as f:
    f.write(str(os.getpid()))
```

**优点**：
- 简单可靠
- 跨进程有效
- 自动清理（通过时效性检查）

### 3. 进程过滤技巧

**方法1**：检查脚本名称

```python
script_name = os.path.basename(sys.argv[0])
if script_name.startswith('migrate_'):
    return  # 跳过迁移脚本
```

**方法2**：检查环境变量（未采用）

```python
if os.environ.get('WORKER_CLASS') == 'gevent':
    # 是gunicorn worker
    pass
```

### 4. 应用上下文管理

在定时任务中访问数据库必须使用应用上下文：

```python
@scheduler.task('interval', minutes=1)
def my_task():
    with app.app_context():  # 必须！
        # 这里可以访问 db.session
        StageService.check_and_update_stages()
```

---

## 部署检查清单

- [x] 添加 `Flask-APScheduler==1.13.1` 到 `requirements.txt`
- [x] 创建 `app/services/scheduler_service.py`
- [x] 在 `app/__init__.py` 中调用 `init_scheduler(app)`
- [x] 在 `start.sh` 中添加 `rm -f /tmp/tg_edu_scheduler_flask.lock`
- [x] 在 `scheduler_service.py` 中过滤迁移脚本
- [x] 配置锁文件机制防止重复执行
- [x] 使用 `docker-compose build --no-cache` 重新构建
- [x] 使用 `docker-compose up -d` 启动服务
- [x] 检查日志确认只有一个worker启动了调度器

---

## 相关文件清单

1. **新增文件**：
   - `app/services/scheduler_service.py` - 调度器服务

2. **修改文件**：
   - `requirements.txt` - 添加 Flask-APScheduler 依赖
   - `app/__init__.py` - 调用调度器初始化
   - `start.sh` - 清理旧锁文件

3. **依赖文件**（已存在）：
   - `app/services/stage_service.py` - 提供 `check_and_update_stages()` 方法
   - `app/models/team.py` - 定义 Stage 模型

---

## 常见问题排查

### Q1: 定时任务没有执行？

**检查步骤**：
1. 查看日志是否有 "🚀 Worker X: 定时任务调度器已启动"
2. 检查锁文件：`docker exec tg-edu-system cat /tmp/tg_edu_scheduler_flask.lock`
3. 查看是否有 "⏰ 定时任务：开始更新阶段状态..." 日志
4. 检查是否有错误日志："❌ 定时任务：阶段状态更新失败"

### Q2: 多个worker都启动了调度器？

**检查步骤**：
1. 搜索日志：`docker logs tg-edu-system 2>&1 | grep "🚀"`
2. 如果看到多个 "🚀"，说明锁文件机制失效
3. 检查 `scheduler_service.py` 中的锁文件逻辑
4. 确认 `start.sh` 中有清理锁文件的命令

### Q3: 所有worker都跳过了调度器？

**检查步骤**：
1. 搜索日志：`docker logs tg-edu-system 2>&1 | grep "调度"`
2. 如果全是 "⚠️ 跳过"，可能是迁移脚本创建了锁文件
3. 检查 `scheduler_service.py` 中是否过滤了迁移脚本
4. 确认 `start.sh` 在启动Gunicorn前清理了锁文件

---

## 未来优化方向

1. **分布式锁**：如果使用多台服务器，需要使用Redis等分布式锁
2. **健康检查**：定期检查调度器是否正常运行
3. **监控告警**：定时任务失败时发送告警
4. **可配置性**：将检查间隔时间配置化，支持动态调整
5. **优雅停机**：容器停止时正确关闭调度器

---

**文档创建时间**：2025-10-21  
**作者**：AI Assistant  
**版本**：v1.0
